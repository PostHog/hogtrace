# HogTrace VM Fuzzing

Comprehensive fuzzing setup for the HogTrace VM parser and compiler to ensure robustness against malformed inputs.

## Overview

We use `cargo-fuzz` (libFuzzer) for continuous fuzzing of the HogTrace VM components. The fuzzing infrastructure tests:

1. **Lexer** - Token generation from arbitrary byte sequences
2. **Parser** - AST generation from source code
3. **Compiler** - Bytecode generation from AST
4. **End-to-End** - Complete pipeline including protobuf serialization

## Quick Start

### Prerequisites

```bash
# Install nightly Rust (required for cargo-fuzz)
rustup install nightly

# Install cargo-fuzz (if not already installed)
cargo install cargo-fuzz
```

### Running Fuzz Tests

```bash
# List all fuzz targets
cargo +nightly fuzz list

# Run a specific target (Ctrl+C to stop)
cargo +nightly fuzz run fuzz_lexer
cargo +nightly fuzz run fuzz_parser
cargo +nightly fuzz run fuzz_compiler
cargo +nightly fuzz run fuzz_end_to_end

# Run with specific options
cargo +nightly fuzz run fuzz_parser -- -max_total_time=300  # 5 minutes
cargo +nightly fuzz run fuzz_parser -- -runs=1000000        # 1M iterations
cargo +nightly fuzz run fuzz_parser -- -jobs=4              # Parallel fuzzing
```

## Fuzz Targets

### 1. `fuzz_lexer` - Lexer Robustness

**Purpose**: Ensures the lexer never panics on arbitrary input

**Properties Tested**:
- UTF-8 decoding is graceful
- All token spans are valid (start â‰¤ end)
- Tokenization always terminates
- No infinite loops on malformed input

**Performance**: ~200k exec/s

### 2. `fuzz_parser` - Parser Robustness

**Purpose**: Ensures the parser never panics and produces valid AST or errors

**Properties Tested**:
- Parse errors are graceful (no panics)
- Valid AST has well-formed structure
- Module/function paths are non-empty
- All expressions and statements are properly constructed

**Performance**: ~150k exec/s
**Coverage**: 566 coverage points, 1700+ features

### 3. `fuzz_compiler` - Compiler Robustness

**Purpose**: Ensures the compiler never panics and produces valid bytecode

**Properties Tested**:
- Compilation errors are graceful (no panics)
- Generated bytecode is valid
- Constant pool is reasonable size (< 100k entries)
- All opcodes are in valid range
- Protobuf serialization succeeds
- Round-trip serialization preserves data

**Performance**: ~145k exec/s
**Coverage**: 671 coverage points

### 4. `fuzz_end_to_end` - Complete Pipeline

**Purpose**: Tests the entire pipeline from source to bytecode to protobuf

**Properties Tested**:
- Complete pipeline never panics
- Protobuf round-trip is deterministic
- All probes are preserved correctly
- Bytecode is identical after deserialization

**Performance**: ~140k exec/s
**Coverage**: 667 coverage points

## Continuous Fuzzing

For continuous integration or long-running fuzzing campaigns:

```bash
# Run all targets in parallel for 1 hour each
for target in fuzz_lexer fuzz_parser fuzz_compiler fuzz_end_to_end; do
    cargo +nightly fuzz run $target -- -max_total_time=3600 -jobs=4 &
done
```

## Crash Analysis

When a crash is found:

```bash
# View the crashing input
cargo +nightly fuzz fmt fuzz_parser artifacts/fuzz_parser/crash-*

# Reproduce the crash
cargo +nightly fuzz run fuzz_parser artifacts/fuzz_parser/crash-*

# Minimize the crashing input
cargo +nightly fuzz tmin fuzz_parser artifacts/fuzz_parser/crash-*
```

## Corpus Management

The fuzzer automatically builds a corpus of interesting inputs:

```bash
# View corpus stats
ls -lh fuzz/corpus/fuzz_parser/

# Add custom test cases to corpus
echo "fn:test:entry { capture(args); }" > fuzz/corpus/fuzz_parser/custom_test
```

## Performance Metrics

Based on initial testing:

| Target | Exec/s | Coverage | Features |
|--------|--------|----------|----------|
| fuzz_lexer | ~200k | 150+ | 180+ |
| fuzz_parser | ~150k | 566 | 1757 |
| fuzz_compiler | ~145k | 671 | 1727 |
| fuzz_end_to_end | ~140k | 667 | 1703 |

## Safety Properties

All fuzz targets verify these critical safety properties:

1. **No Panics**: Parser/compiler never panics on any input
2. **Graceful Errors**: Invalid input produces `ParseError` or `CompileError`, not crashes
3. **Bounded Resources**: No unbounded memory allocation or infinite loops
4. **Valid Output**: When successful, output always satisfies invariants

## Integration with CI

Add to your CI pipeline:

```yaml
- name: Fuzz Testing
  run: |
    rustup install nightly
    cargo install cargo-fuzz
    cargo +nightly fuzz run fuzz_parser -- -max_total_time=60 -runs=0
    cargo +nightly fuzz run fuzz_compiler -- -max_total_time=60 -runs=0
```

## Related Documentation

- [cargo-fuzz book](https://rust-fuzz.github.io/book/cargo-fuzz.html)
- [libFuzzer documentation](https://llvm.org/docs/LibFuzzer.html)
- [HogTrace Parser Implementation](../src/parser/)

## Troubleshooting

**Issue**: `error: the option 'Z' is only accepted on the nightly compiler`
**Solution**: Always use `cargo +nightly fuzz` command

**Issue**: Fuzzing is slow
**Solution**: Use `-jobs=N` for parallel fuzzing, or reduce input size limit

**Issue**: Out of memory
**Solution**: Reduce `-rss_limit_mb` parameter or run fewer parallel jobs

## Contributing

When adding new features to the parser/compiler, add corresponding property tests to the fuzz targets to ensure robustness.
